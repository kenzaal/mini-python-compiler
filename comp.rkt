;; veuillez mettre la tabulation à 2 si ce n'est pas fait car les lignes risque de se decaler;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#lang racket/base

(require racket/match)

(require "ast.rkt" "lexer.rkt" "parser.rkt")

(provide mips-emit mips-data mips-compile)

;;compiler les expressions et les opérations
(define (comp prog env fp-sp) 
  (match prog
    
     ((Pval v)  v)
     ((Pid name)  (hash-ref env name))
     ((Pdef id expr)  (hash-set env id (comp expr env fp-sp))) ;; declaration de variables
     ((Pcond test yes no)  (hash-set env (comp test env fp-sp) (comp yes env fp-sp) (comp yes env fp-sp)))
     ((Pop op v1 v2)
           (match op
             ('add (+ (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('sub (- (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('mul (* (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('div (/ (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('sup (> (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('inf (< (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('seq (>= (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('ieq (<= (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('eq  (= (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('neq (= (comp v1 env fp-sp) (comp v2 env fp-sp)))
             ('mod (modulo (comp v1 env fp-sp) (comp v2 env fp-sp)))))))
       
;;"matcher" les instructions mips
(define (mips-emit instr)
  (match instr
    ((Move rd rs)   (printf "move $~a, $~a\n" rd rs))
    ((Li r i)       (printf "li $~a, ~a\n" r i))
    ((La r a)       (printf "la $~a, ~a\n" r (mips-loc a)))
    ((Addi rd rs i) (printf "addi $~a, $~a, ~a\n" rd rs i))
    ((Add rd rs r)  (printf "add $~a, $~a, $~a\n" rd rs r))
    ((Sub rd rs i)  (printf "sub $~a, $~a, ~a\n" rd rs i))
    ((Mult r1 r2)   (printf "mult $~a, $~a\n" r1 r2))
    ((Div r1 r2)    (printf "div $~a, $~a\n" r1 r2))
    ((Mflo rs)      (printf "mflo $~a\n" rs))
    ((Mfhi rs)      (printf "mfhi $~a\n" rs))
    ((Sw r loc)     (printf "sw $~a, ~a\n" r (mips-loc loc)))
    ((Lw r loc)     (printf "lw $~a, ~a\n" r (mips-loc loc)))
    ((Syscall)      (printf "syscall\n"))
    ((Jr r)         (printf "jr $~a\n" r))
    ((Beq r1 r2 lbl)(printf "beq $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bgt r1 r2 lbl)(printf "bgt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Blt r1 r2 lbl)(printf "blt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bge r1 r2 lbl)(printf "bge $~a, $~a, ~a\n" r1 r2 lbl))
    ((Ble r1 r2 lbl)(printf "ble $~a, $~a, ~a\n" r1 r2 lbl))
    ((B lbl)        (printf "b ~a\n" lbl))
    ((Label l)      (printf "~a:\n" l))))

(define (mips-loc loc)
  (match loc
    ((Lbl l)   (format "~a" l))
    ((Mem b r) (format "~a($~a)" b r))))

(define (mips-data data)
  (printf "\n.data\n")
  (hash-for-each data
     (lambda (k v)
	(if (number? v)
           (printf "~a: .word ~s\n" k v)
           (printf "~a: .asciiz ~s\n" k v))))
  (printf ".text\n.globl main\nmain:\n"))

(list (mips-data (make-hash '((nl . "\n") (f . "\nFalse\n") (t . "\nTrue\n") (m . "\nNameError: the entered name is not defined\n"))))) 
;;traduction des expressions en instructions mips
(define (mips-compile prog env)
(for-each mips-emit 
  (append
  
    (match prog

      ;; le code entré peut être un numero qui sera affiché aprés la compilation
      ((list (Pval v))      
        (append  (list (Li 'v0 1))
                 (list (La 'a0 (Lbl v)))
                 (list (Syscall))))                
         

      ;; ou un mot/lettre mais cela envoie un message d'erreur car le mot entré n'est pas identifié
      ((list (Pid n))       
        (append (list (Li 'v0 4))
                (list (La 'a0 (Lbl n)))
                (list (Syscall))))              
        	

      ;; definition de varaibles
      ((Pdef id v) 
        (list (mips-data (hash 'val (comp v env 0) 'nl "\n")))  
        (append (list (Lw 't0 (Lbl 'val)))))               
          

      ;; if
      ((list (Pcond test yes no))                     
        (mips-compile (list test) env)
        (list (Beq 't0 '0 'Else))
        (mips-compile (list yes) env)
        (list (B 'Endif))
        (list (Label 'Else))
        (mips-compile (list no) env)
        (list (Label 'Endif)) 
        (list (Syscall)))          
         

      ;; ou bien des operations                              
	    ((list (Pop op v1 v2))
        (match op 
          ('add (append (list (Li 't0 (comp v1 env 0)))
		                    (list (Addi 't0 't0 (comp v2 env 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))						         
                        (list (Syscall))))
          ('sub (append (list (Li 't0 (comp v1 env 0)))
					              (list (Sub 't0 't0 (comp v2 env 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))
										    (list (Syscall))))
					('mul (append (list (Li 't0 (comp v1 env 0)))
											  (list (Li 't1 (comp v2 env 0)))
												(list (Mult 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
										    (list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
				  ('div (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
					('sup (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bgt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('inf (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Blt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('seq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bge 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
					('ieq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Ble 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
											  (list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('eq  (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Beq 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('neq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
											  (list (Beq 't0 't1 'FALSE))
												(list (B 'TRUE))
												(list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('mod (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mfhi 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall)))))) )
                                   
	  (list  (Li 'v0 4)																				 
          (La 'a0 (Lbl 'nl))
          (Syscall)
          (Li 'v0 0)
          (Jr 'ra))
           )))
