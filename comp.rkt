;; veuillez mettre la tabulation à 2 si ce n'est pas fait car les lignes risque de se decaler;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#lang racket/base

(require racket/match)

(require "ast.rkt" "lexer.rkt" "parser.rkt")

(provide mips-data prog-eval mips-exit main data-eval data)

;;fonction principal pour savoir si le programme se compse d'une seule instruction ou bien d'un ensemble d'instructions
(define (prog-eval prog env)
  (match prog
    ((cons (Pdef id v) expr) (mips-compile (Pdef id v) env) (prog-eval expr env))
    ((Pdef id v) (mips-compile prog env))
    ((list expr) (mips-compile prog env))
    ((cons expr1 expr2)  (mips-compile (list expr1) env) (prog-eval expr2 env))))

;;défine les data des expressions
(define (data-eval prog env)
  (match prog
    ((Pdef id v) (match-data (list prog) env))
    ((list expr) (match-data prog env))
    ((cons expr1 expr2)  (match-data (list expr1) env) (data-eval expr2 env))))

;;affiche les instructions mips de fin de chaque programme 
(define (mips-exit)
  (printf "li $v0, 4\nla $a0, nl\nsyscall\nli $v0, 0\njr $ra\n"))
 
;;compiler les expressions et les opérations
(define (comp prog env fp-sp) 
  (match prog 
     ((Pbool b)              (if b 1 0)) 
     (#f                     0)
     (#t                     1)
     ((Pval v)               v)
     ((Pid name)             name)
     ((Pdef id expr)         (hash-set env id (comp expr env fp-sp))) ;; declaration de variables
     ((Pcond test yes no)    (hash-set env (comp test env fp-sp) (comp yes env fp-sp) (comp no env fp-sp)))
     ((Ploop test instr)     (hash-set env (comp test env fp-sp) (comp instr env fp-sp)))
     ((Pprint expr)          (hash-set env (comp expr env fp-sp)))
     ((Pnot op v)            ('not (comp (not (comp v env fp-sp)) env fp-sp)))
     ((Pop op v1 v2)         (match op
                                ('add (+  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('sub (-  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('mul (*  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('div (/  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('sup (>  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('inf (<  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('seq (>= (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('ieq (<= (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('eq  (=  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('neq (=  (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('mod (modulo (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('and (and (comp v1 env fp-sp) (comp v2 env fp-sp)))
                                ('or  (or (comp v1 env fp-sp) (comp v2 env fp-sp)))))))
       
;;"matcher" les instructions mips
(define (mips-emit instr)
  (match instr
    ((Move rd rs)   (printf "move $~a, $~a\n" rd rs))
    ((Li r i)       (printf "li $~a, ~a\n" r i))
    ((La r a)       (printf "la $~a, ~a\n" r (mips-loc a)))
    ((Addi rd rs i) (printf "addi $~a, $~a, ~a\n" rd rs i))
    ((Add rd rs r)  (printf "add $~a, $~a, $~a\n" rd rs r))
    ((Sub rd rs i)  (printf "sub $~a, $~a, ~a\n" rd rs i))
    ((Mult r1 r2)   (printf "mult $~a, $~a\n" r1 r2))
    ((Div r1 r2)    (printf "div $~a, $~a\n" r1 r2))
    ((Mflo rs)      (printf "mflo $~a\n" rs))
    ((Mfhi rs)      (printf "mfhi $~a\n" rs))
    ((Sw r loc)     (printf "sw $~a, ~a\n" r (mips-loc loc)))
    ((Lw r loc)     (printf "lw $~a, ~a\n" r (mips-loc loc)))
    ((Syscall)      (printf "syscall\n"))
    ((Jr r)         (printf "jr $~a\n" r))
    ((Beq r1 r2 lbl)(printf "beq $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bgt r1 r2 lbl)(printf "bgt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Blt r1 r2 lbl)(printf "blt $~a, $~a, ~a\n" r1 r2 lbl))
    ((Bge r1 r2 lbl)(printf "bge $~a, $~a, ~a\n" r1 r2 lbl))
    ((Ble r1 r2 lbl)(printf "ble $~a, $~a, ~a\n" r1 r2 lbl))
    ((And rd r1 r2) (printf "and $~a, $~a, $~a\n"rd r1 r2))
    ((Or rd r1 r2)  (printf "or $~a, $~a, $~a\n"rd r1 r2))
    ((Xor rd r1 r2) (printf "xor $~a, $~a, $~a\n"rd r1 r2))
    ((B lbl)        (printf "b ~a\n" lbl))
    ((Label l)      (printf "~a:\n" l))))

;;match les labels est les emplacement dans la pile
(define (mips-loc loc)
  (match loc
    ((Lbl l)   (format "~a" l))
    ((Mem b r) (format "~a($~a)" b r))))

(define (data)
   (printf"\n.data\n"))

;;cette fonction sert à charger des mots dans un .data
(define (mips-data data)
  (hash-for-each data
     (lambda (k v)
	     (if (number? v)
           (printf "~a: .word ~s\n" k v)
           (printf "~a: .asciiz ~s\n" k v)))))

;;cette fonction affiche les informations nécessaire pour le programme spim
(define (main)
  (printf ".text\n.globl main\nmain:\n"))

;;la fonction print-data sert à charger la chaîne de caractére mise dans le print dans le .data
(define (print-data data)
  (hash-for-each data
    (lambda (k v)
      (printf "~a: .asciiz \"~s\"\n" k v))))

;;ces deux fonctions sont utilisé pour les instructions de if
(define (mips-beq)   (printf "beq $v0, $0, Else\n"))
(define (mips-label) (printf "b Endif\nElse:\n"))
(define (mips-loop)  (printf "loop:\nbeq $v0, $0, end_loop\n"))
(define (mips-bloop) (printf "b loop\n"))

;;la fonction mips-if-compile match les programme que peut contenir un if
(define (mips-if-compile prog env)
 (for-each mips-emit 
  (append
   (match prog
     ((list (Pbool v))     (append (list (Li 'v0 (comp v env 0)))))
     ;;un numero
     ((list (Pval v))      (append (list (Li 'v0 v))))
     ;;déclaration de variable
     ((Pdef id v)          (append (list (Lw 't0 (Lbl 'val)))))
     ;;print
     ((list (Pprint expr)) (append (list (Li 'v0 4))
                                   (list (La 'a0 (Lbl (comp expr env 0))))
                                   (list (Syscall))
                                   (list (Li 'v0 4))
                                   (list (La 'a0 (Lbl 'nl)))
								                   (list (Syscall))))
    ;;afficher des opérations ,chiffres ou autres...
    ((list (Pprint_op expr))
     (list (mips-compile (list expr) env))
     (append (list (Li 'v0 4))
             (list (La 'a0 (Lbl 'nl)))
					   (list (Syscall))))
   ;;opération
    ((list (Pop op v1 v2))
        (match op 
          ('add (append (list (Li 't0 (comp v1 env 0)))
		                    (list (Addi 'v0 't0 (comp v2 env 0)))))
          ('sub (append (list (Li 't0 (comp v1 env 0)))
					              (list (Sub 'v0 't0 (comp v2 env 0)))))
					('mul (append (list (Li 't0 (comp v1 env 0)))
											  (list (Li 't1 (comp v2 env 0)))
												(list (Mult 't0 't1))
												(list (Mflo 's0))
										    (list (Add 'v0 'zero 's0))))
				  ('div (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mflo 's0))
												(list (Add 'v0 'zero 's0))))
					('sup (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bgt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('inf (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Blt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('seq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bge 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
					('ieq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Ble 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
											  (list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('eq  (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Beq 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 1))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 0))
                        (list (Label 'next))))
          ('neq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
											  (list (Beq 't0 't1 'FALSE))
												(list (B 'TRUE))
												(list (Label 'FALSE))
                        (list (Li 'v0 0))
												(list (B 'next))
                        (list (Label 'TRUE))
                        (list (Li 'v0 1))
                        (list (Label 'next))))
          ('mod (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mfhi 's0))
												(list (Add 'v0 'zero 's0))))
          ('and (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
                        (list (And 'v0 't0 't1))))
          ('or  (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
                        (list (Or 'v0 't0 't1)))))))))) 

;;afficher les .data qui correspond au instructions du programme
(define (match-data prog env)
 (append 
    (match prog
      ((list (Pbool v))           '())
      ((list (Pnot op v))         '())
      ((list (Pval v))            '())
      ((list (Pid n))             (list (mips-data (make-hash '((n . "\nNameError: the entered name is not defined\n"))))))
      ((list (Pdef id v))         (mips-data (hash (comp id env 0) (comp v env 0))))
      ((list (Pop op v1 v2))      '())
      ((list (Pprint expr))       (print-data (hash (comp expr env 0) (comp expr env 0))))
      ((list (Pcond test yes no)) 
                                  (match-data (list test) env)
       													  (match-data (list yes) env)
       													  (match-data (list no) env))
      ((list (Ploop test instr)) 
                                  (match-data (list test) env)
       													  (match-data (list instr) env))
     ((list (Pprint_op expr))     (match-data (list expr) env)))))

;;traduction des expressions en instructions mips
(define (mips-compile prog env)
 (for-each mips-emit 
   (append
    (match prog
       ((list (Pbool v))  (append (list (Li 'v0 1))
                                  (list (La 'a0 (Lbl (comp v env 0))))
                                  (list (Syscall)))) 
      ;; le code entré peut être un numero qui sera affiché aprés la compilation
      ((list (Pval v))    (append  (list (Li 'v0 1))
                                   (list (La 'a0 (Lbl v)))
                                   (list (Syscall)))) 
               
      ;; ou un mot/lettre mais cela envoie un message d'erreur car le mot entré n'est pas identifié
      ((list (Pid n))     (append (list (Li 'v0 4))
                                  (list (La 'a0 (Lbl 'n)))
                                  (list (Syscall))))              
                                         
      ;; definition de varaibles
      ((Pdef id v)        (append (list (Lw 't0 (Lbl (comp id env 0))))))

      ;; if condition yes no
      ((list (Pcond test yes no))   
        (mips-if-compile (list test) env)
        (mips-beq)
        (mips-if-compile (list yes) env)
        (mips-label)
        (mips-if-compile (list no) env)
        (list (Label 'Endif)))
    
     ;;while loop
     ((list (Ploop test instr))
       (mips-if-compile (list test) env)
       (mips-loop)
       (mips-if-compile (list instr) env)
       (mips-bloop)
       (list (Label 'end_loop)))
         
      ;;print('expr')
      ((list (Pprint expr))
        (append (list (Li 'v0 4))
                (list (La 'a0 (Lbl (comp expr env 0))))
                (list (Syscall))
                (list (Li 'v0 4))
                (list (La 'a0 (Lbl 'nl)))
								(list (Syscall))))
      
      ;;print a number or an operation ...
      ((list (Pprint_op expr))
        (list (mips-compile (list expr) env))
        (append (list (Li 'v0 4))
                (list (La 'a0 (Lbl 'nl)))
								(list (Syscall))))

       ((list (Pnot op v)) (append (list (Li 't0 (comp v env 0)))
												           (list (Li 't1 1))
                                   (list (Xor 'a0 't0 't1))
                                   (list (Li 'v0 1))
												           (list (Syscall)))) 
      ;; ou bien des operations                              
	    ((list (Pop op v1 v2))
        (match op 
          ('add (append (list (Li 't0 (comp v1 env 0)))
		                    (list (Addi 't0 't0 (comp v2 env 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))						         
                        (list (Syscall))))
          ('sub (append (list (Li 't0 (comp v1 env 0)))
					              (list (Sub 't0 't0 (comp v2 env 0)))
				                (list (Li 'v0 1))
				                (list (Move 'a0 't0))
										    (list (Syscall))))
					('mul (append (list (Li 't0 (comp v1 env 0)))
											  (list (Li 't1 (comp v2 env 0)))
												(list (Mult 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
										    (list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
				  ('div (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mflo 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
					('sup (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bgt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('inf (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Blt 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('seq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Bge 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
					('ieq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Ble 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
											  (list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('eq  (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Beq 't0 't1 'TRUE))
												(list (B 'FALSE))
												(list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('neq (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
											  (list (Beq 't0 't1 'FALSE))
												(list (B 'TRUE))
												(list (Label 'FALSE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 'f)))
                        (list (Syscall))
												(list (B 'next))
                        (list (Label 'TRUE))
                        (list (Li 'v0 4))
                        (list (La 'a0 (Lbl 't)))
                        (list (Syscall))
                        (list (Label 'next))))
          ('mod (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
												(list (Div 't0 't1))
												(list (Mfhi 's0))
                        (list (Li 'v0 1))
												(list (Add 'a0 'zero 's0))
		                    (list (Syscall))))
          ('and (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
                        (list (And 't2 't0 't1))
                        (list (Li 'v0 1))
                        (list (Move 'a0 't2))
												(list (Syscall))))
          ('or  (append (list (Li 't0 (comp v1 env 0)))
												(list (Li 't1 (comp v2 env 0)))
                        (list (Or 't2 't0 't1))
                        (list (Li 'v0 1))
                        (list (Move 'a0 't2))
												(list (Syscall))))))))))
